# 內購整合實作指南

## 📋 概述

本指南將協助您完成 Google Play 和 App Store 內購的完整整合。

**已完成項目**：
- ✅ `usePurchase` hook（前端購買邏輯）
- ✅ `initiate-purchase` Edge Function（初始化購買）
- ✅ `verify-google-play-purchase` Edge Function（驗證 Google Play 購買）
- ✅ `verify-app-store-purchase` Edge Function（驗證 App Store 購買）
- ✅ `RechargePage` 已更新使用真實購買流程

**待完成項目**：
- ⚠️ Android 原生 Google Play Billing 整合
- ⚠️ iOS 原生 StoreKit 整合
- ⚠️ 後端購買驗證的完整實作

---

## 🔧 第一部分：Android Google Play 內購整合

### 步驟 1：在 Android 專案中添加 Google Play Billing Library

1. 打開 `android/app/build.gradle`
2. 在 `dependencies` 區塊中添加：

```gradle
dependencies {
    // ... 其他依賴 ...
    implementation 'com.android.billingclient:billing:6.0.0'
    implementation 'com.android.billingclient:billing-ktx:6.0.0'
}
```

3. 同步 Gradle

### 步驟 2：建立 Android 原生內購插件

建立 `android/app/src/main/java/com/votechaos/app/InAppPurchasePlugin.java`：

```java
package com.votechaos.app;

import android.app.Activity;
import com.getcapacitor.JSObject;
import com.getcapacitor.Plugin;
import com.getcapacitor.PluginCall;
import com.getcapacitor.PluginMethod;
import com.getcapacitor.annotation.CapacitorPlugin;
import com.android.billingclient.api.*;

@CapacitorPlugin(name = "InAppPurchase")
public class InAppPurchasePlugin extends Plugin {
    private BillingClient billingClient;
    private PurchaseUpdatedListener purchaseUpdatedListener;

    @Override
    public void load() {
        super.load();
        
        purchaseUpdatedListener = (billingResult, purchases) -> {
            if (billingResult.getResponseCode() == BillingClient.BillingResponseCode.OK && purchases != null) {
                for (Purchase purchase : purchases) {
                    handlePurchase(purchase);
                }
            }
        };
        
        billingClient = BillingClient.newBuilder(getContext())
            .setListener(purchaseUpdatedListener)
            .enablePendingPurchases()
            .build();
            
        billingClient.startConnection(new BillingClientStateListener() {
            @Override
            public void onBillingSetupFinished(BillingResult billingResult) {
                if (billingResult.getResponseCode() == BillingClient.BillingResponseCode.OK) {
                    // Billing client is ready
                }
            }

            @Override
            public void onBillingServiceDisconnected() {
                // Try to restart the connection
            }
        });
    }

    @PluginMethod
    public void purchase(PluginCall call) {
        String productId = call.getString("productId");
        if (productId == null) {
            call.reject("productId is required");
            return;
        }

        SkuDetailsParams.Builder params = SkuDetailsParams.newBuilder();
        params.setSkusList(java.util.Arrays.asList(productId))
            .setType(BillingClient.SkuType.INAPP);

        billingClient.querySkuDetailsAsync(params.build(), (billingResult, skuDetailsList) -> {
            if (billingResult.getResponseCode() == BillingClient.BillingResponseCode.OK && skuDetailsList != null) {
                for (SkuDetails skuDetails : skuDetailsList) {
                    BillingFlowParams flowParams = BillingFlowParams.newBuilder()
                        .setSkuDetails(skuDetails)
                        .build();
                    BillingResult result = billingClient.launchBillingFlow(getActivity(), flowParams);
                    if (result.getResponseCode() != BillingClient.BillingResponseCode.OK) {
                        call.reject("Failed to launch billing flow: " + result.getResponseCode());
                    }
                }
            } else {
                call.reject("Failed to query product details");
            }
        });
    }

    private void handlePurchase(Purchase purchase) {
        if (purchase.getPurchaseState() == Purchase.PurchaseState.PURCHASED) {
            // 通知前端購買成功
            JSObject result = new JSObject();
            result.put("purchaseToken", purchase.getPurchaseToken());
            result.put("productId", purchase.getSkus().get(0));
            notifyListeners("purchaseSuccess", result);
            
            // 確認購買
            AcknowledgePurchaseParams acknowledgePurchaseParams = AcknowledgePurchaseParams.newBuilder()
                .setPurchaseToken(purchase.getPurchaseToken())
                .build();
            billingClient.acknowledgePurchase(acknowledgePurchaseParams, (billingResult) -> {
                // 處理確認結果
            });
        }
    }
}
```

### 步驟 3：註冊插件

在 `MainActivity.java` 中註冊插件：

```java
import com.votechaos.app.InAppPurchasePlugin;

public class MainActivity extends BridgeActivity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        registerPlugin(InAppPurchasePlugin.class);
    }
}
```

### 步驟 4：在前端使用插件

更新 `src/hooks/usePurchase.tsx` 中的 `handleNativePurchase`：

```typescript
// 處理原生 App 內購
const handleNativePurchase = async (
  packageId: number,
  productId: string,
  platform: string
) => {
  if (platform === 'android') {
    // 使用 Capacitor 插件
    const { InAppPurchase } = await import('@/plugins/InAppPurchase');
    
    // 監聽購買成功事件
    InAppPurchase.addListener('purchaseSuccess', async (result: any) => {
      // 驗證購買
      const { data, error } = await supabase.functions.invoke('verify-google-play-purchase', {
        body: {
          purchaseToken: result.purchaseToken,
          productId: result.productId,
        },
      });

      if (error) throw error;

      // 顯示成功訊息
      const productInfo = PRODUCT_ID_MAP[packageId];
      const totalTokens = (productInfo.tokens + productInfo.bonus).toLocaleString();
      toast.success('購買成功！', {
        description: `已獲得 ${totalTokens} 代幣`,
      });

      await refreshProfile();
    });

    // 發起購買
    await InAppPurchase.purchase({ productId });
  } else if (platform === 'ios') {
    // iOS 實作（見下方）
  }
};
```

---

## 🍎 第二部分：iOS App Store 內購整合

### 步驟 1：在 iOS 專案中添加 StoreKit

1. 打開 Xcode 專案
2. 在 `ios/App/App.xcodeproj` 中，確保已導入 StoreKit 框架（通常已包含）

### 步驟 2：建立 iOS 原生內購插件

建立 `ios/App/App/Plugins/InAppPurchasePlugin.swift`：

```swift
import Foundation
import Capacitor
import StoreKit

@objc(InAppPurchasePlugin)
public class InAppPurchasePlugin: CAPPlugin {
    private var products: [SKProduct] = []
    
    @objc func purchase(_ call: CAPPluginCall) {
        guard let productId = call.getString("productId") else {
            call.reject("productId is required")
            return
        }
        
        // 請求產品資訊
        let productIds = Set([productId])
        let request = SKProductsRequest(productIdentifiers: productIds)
        request.delegate = self
        
        // 開始購買
        request.start()
    }
}

extension InAppPurchasePlugin: SKProductsRequestDelegate {
    public func productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) {
        if let product = response.products.first {
            let payment = SKPayment(product: product)
            SKPaymentQueue.default().add(payment)
        }
    }
}

extension InAppPurchasePlugin: SKPaymentTransactionObserver {
    public func paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) {
        for transaction in transactions {
            switch transaction.transactionState {
            case .purchased:
                // 購買成功
                let result = [
                    "purchaseToken": transaction.transactionIdentifier ?? "",
                    "productId": transaction.payment.productIdentifier,
                    "receiptData": getReceiptData()
                ]
                notifyListeners("purchaseSuccess", data: result)
                queue.finishTransaction(transaction)
                
            case .failed:
                queue.finishTransaction(transaction)
                
            case .restored:
                queue.finishTransaction(transaction)
                
            default:
                break
            }
        }
    }
    
    private func getReceiptData() -> String {
        guard let receiptURL = Bundle.main.appStoreReceiptURL,
              let receiptData = try? Data(contentsOf: receiptURL) else {
            return ""
        }
        return receiptData.base64EncodedString()
    }
}
```

### 步驟 3：在前端使用插件

更新 `src/hooks/usePurchase.tsx` 中的 iOS 部分：

```typescript
if (platform === 'ios') {
  const { InAppPurchase } = await import('@/plugins/InAppPurchase');
  
  // 監聽購買成功事件
  InAppPurchase.addListener('purchaseSuccess', async (result: any) => {
    // 驗證購買
    const { data, error } = await supabase.functions.invoke('verify-app-store-purchase', {
      body: {
        receiptData: result.receiptData,
        productId: result.productId,
      },
    });

    if (error) throw error;

    // 顯示成功訊息
    const productInfo = PRODUCT_ID_MAP[packageId];
    const totalTokens = (productInfo.tokens + productInfo.bonus).toLocaleString();
    toast.success('購買成功！', {
      description: `已獲得 ${totalTokens} 代幣`,
    });

    await refreshProfile();
  });

  // 發起購買
  await InAppPurchase.purchase({ productId });
}
```

---

## 🔐 第三部分：後端驗證設定

### 步驟 1：設定 Google Play Service Account

1. 前往 [Google Cloud Console](https://console.cloud.google.com/)
2. 建立 Service Account
3. 下載 JSON 金鑰檔案
4. 在 Supabase Dashboard > Settings > Secrets 中添加：
   - `GOOGLE_PLAY_SERVICE_ACCOUNT_EMAIL`
   - `GOOGLE_PLAY_PRIVATE_KEY`（從 JSON 檔案中提取）

### 步驟 2：設定 App Store Shared Secret

1. 前往 [App Store Connect](https://appstoreconnect.apple.com/)
2. 導航到「我的 App」>「App 內購買項目」
3. 點擊「App 專用共用密鑰」
4. 複製 Shared Secret
5. 在 Supabase Dashboard > Settings > Secrets 中添加：
   - `APP_STORE_SHARED_SECRET`

### 步驟 3：部署 Edge Functions

```bash
# 部署初始化購買函數
npx supabase functions deploy initiate-purchase

# 部署 Google Play 驗證函數
npx supabase functions deploy verify-google-play-purchase

# 部署 App Store 驗證函數
npx supabase functions deploy verify-app-store-purchase
```

---

## ✅ 測試流程

### Android 測試

1. 在 Google Play Console 中建立測試帳號
2. 將應用上傳到內部測試軌道
3. 使用測試帳號登入設備
4. 在 App 中測試購買流程

### iOS 測試

1. 在 App Store Connect 中建立沙盒測試帳號
2. 在設備上登出 App Store
3. 在 App 中測試購買，會自動使用沙盒環境
4. 使用測試帳號完成購買

---

## 📝 重要注意事項

### 安全性
- ⚠️ **永遠在後端驗證購買**，不要只依賴前端驗證
- ⚠️ **檢查重複購買**，防止重複發放代幣
- ⚠️ **記錄所有交易**，用於審計和退款處理

### 產品 ID
- 確保產品 ID 與 Google Play / App Store 中設定的完全一致
- 產品 ID 區分大小寫

### 測試
- 使用測試環境測試所有購買流程
- 測試購買失敗、取消、退款等情況

---

**最後更新**：2025年1月

